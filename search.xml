<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>numpy</title>
    <url>/2021/05/06/numpy/</url>
    <content><![CDATA[<h2 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h2><hr>
<p>通过这几天的联系,对于python的数据类型,基础操作和几个方面的小扩展都有了一定的掌握,现在把机器学习常用的库再重温一下,看看会不会有什么新的发现.</p>
<h4 id="Ndarray-对象"><a href="#Ndarray-对象" class="headerlink" title="Ndarray 对象"></a>Ndarray 对象</h4><p>NumPy 最重要的一个特点是其 N 维数组对象 ndarray，它是一系列同类型数据的集合，以 0 下标为开始进行集合中元素的索引。其能够存贮多维数组,而且每个元素占据的空间相同</p>
<span id="more"></span>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">np.array([1,2,3])   #可以用来生成数组</span><br><span class="line">&gt;[1 2 3 ]</span><br><span class="line">np.array([1,2,3],ndmin&#x3D;2)   #规定最小维度</span><br><span class="line">&gt;[[1 2 3 ]]</span><br><span class="line">a &#x3D; np.array([1,  2,  3], dtype &#x3D; complex) </span><br><span class="line">print(a)        #dtype可以规定数组内数据类型</span><br><span class="line">&gt;[1.+0.j 2.+0.j 3.+0.j]</span><br></pre></td></tr></table></figure>

<p>ndarray 对象由计算机内存的连续一维部分组成,和一般存储数组的方法是一致的.</p>
<p>dtype是一个列表嵌套元组的返回值,指明每个位置的名称和应该有的数据类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">student &#x3D; np.dtype([(&#39;name&#39;,&#39;S20&#39;), (&#39;age&#39;, &#39;i1&#39;), (&#39;marks&#39;, &#39;f4&#39;)]) </span><br><span class="line">a &#x3D; np.array([(&#39;abc&#39;, 21, 50),(&#39;xyz&#39;, 18, 75)], dtype &#x3D; student) </span><br><span class="line">print(a)</span><br><span class="line">[(b&#39;abc&#39;, 21, 50.) (b&#39;xyz&#39;, 18, 75.)]</span><br><span class="line">a[&#39;name&#39;]</span><br><span class="line">Out[12]: array([b&#39;abc&#39;, b&#39;xyz&#39;], dtype&#x3D;&#39;|S20&#39;)</span><br><span class="line">a[&#39;age&#39;]</span><br><span class="line">Out[13]: array([21, 18], dtype&#x3D;int8)</span><br><span class="line">a[&#39;marks&#39;]</span><br><span class="line">Out[14]: array([50., 75.], dtype&#x3D;float32)</span><br></pre></td></tr></table></figure>

<h4 id="NumPy-数组属性"><a href="#NumPy-数组属性" class="headerlink" title="NumPy 数组属性"></a>NumPy 数组属性</h4><p>reshape可以调整数组形状,他是产生副本,直接reshape不会改变数组对象的形状,需要赋值给自己.<br><br>而且reshape的参数要注意和数组元素个数匹配,否则会出现异常.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;np.arange(12)</span><br><span class="line">a.reshape(2,2,3)</span><br><span class="line">Out[13]: </span><br><span class="line">array([[[ 0,  1,  2],</span><br><span class="line">        [ 3,  4,  5]],</span><br><span class="line">       [[ 6,  7,  8],</span><br><span class="line">        [ 9, 10, 11]]])</span><br><span class="line">a</span><br><span class="line">Out[16]: array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</span><br></pre></td></tr></table></figure>

<p>itemsize<br></p>
<p>用来检查数组每一个元素的大小.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.itemsize</span><br><span class="line">Out[22]: 4</span><br></pre></td></tr></table></figure>

<p>####创建numpy数组</p>
<p>empty申请数组空间,参数指定形状,数据格式,排序方式(c行优先,f列优先)<br>zeros同理,但所有元素赋值为零<br>ones一样,所有元素赋值为1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;np.empty([1,2,3],dtype&#x3D;int,order&#x3D;&#39;C&#39;)</span><br><span class="line">a.shape</span><br><span class="line">Out[26]: (1, 2, 3)</span><br><span class="line">a.itemsize</span><br><span class="line">Out[27]: 4</span><br></pre></td></tr></table></figure>

<p>使用array和asarray都可直接用列表,元组来建立数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;np.array([1,2,3])</span><br><span class="line">a</span><br><span class="line">Out[32]: array([1, 2, 3])</span><br><span class="line">a&#x3D;np.asarray([1,2,3])</span><br><span class="line">a</span><br><span class="line">Out[34]: array([1, 2, 3])</span><br><span class="line">a&#x3D;np.asarray((1,2,3,4))</span><br><span class="line">a</span><br><span class="line">Out[36]: array([1, 2, 3, 4])</span><br><span class="line">a&#x3D;np.asarray((1,2,3,4),dtype&#x3D;float)</span><br><span class="line">a</span><br><span class="line">Out[38]: array([1., 2., 3., 4.])</span><br></pre></td></tr></table></figure>
<p>frombuffer可用于实现动态数组<br>接收参数以流的形式读入转化成 ndarray 对象<br>字符串前面的b表示类型为bytestring</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D;  b&#39;Hello World&#39; </span><br><span class="line">a &#x3D; np.frombuffer(s, dtype &#x3D;  &#39;S1&#39;) </span><br><span class="line">a</span><br><span class="line">Out[51]: </span><br><span class="line">array([b&#39;H&#39;, b&#39;e&#39;, b&#39;l&#39;, b&#39;l&#39;, b&#39;o&#39;, b&#39; &#39;, b&#39;W&#39;, b&#39;o&#39;, b&#39;r&#39;, b&#39;l&#39;, b&#39;d&#39;],</span><br><span class="line">      dtype&#x3D;&#39;|S1&#39;)</span><br></pre></td></tr></table></figure>
<p>使用arange可以以生成和range一样的结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;np.arange(1,10,2)</span><br><span class="line">a</span><br><span class="line">Out[4]: array([1, 3, 5, 7, 9])</span><br></pre></td></tr></table></figure>

<p>linspace 用于创建一个一维数组，数组是一个等差数列构成的,参数分别是起始,终止,数字元素数目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;np.linspace(1,2,10)</span><br><span class="line">a</span><br><span class="line">Out[10]: </span><br><span class="line">array([1.        , 1.11111111, 1.22222222, 1.33333333, 1.44444444,</span><br><span class="line">       1.55555556, 1.66666667, 1.77777778, 1.88888889, 2.        ])</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">a&#x3D;np.linspace(1,2,10,dtype&#x3D;int)</span><br><span class="line">a</span><br><span class="line">Out[14]: array([1, 1, 1, 1, 1, 1, 1, 1, 1, 2])</span><br></pre></td></tr></table></figure>

<p>logspace 函数用于创建一个于等比数列,参数也分别是起始,终止,数字元素数目,有endpoint表示算不算最后一个,base代表底数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;np.linspace(1,200,10,dtype&#x3D;int)</span><br><span class="line">a</span><br><span class="line">Out[16]: array([  1,  23,  45,  67,  89, 111, 133, 155, 177, 200])</span><br><span class="line">a &#x3D; np.logspace(1.0,  2.0, num &#x3D;  1) </span><br><span class="line">a</span><br><span class="line">Out[18]: array([10.])</span><br><span class="line">a &#x3D; np.logspace(1.0,  2.0, num &#x3D;  2) </span><br><span class="line">a</span><br><span class="line">Out[20]: array([ 10., 100.])</span><br><span class="line">a &#x3D; np.logspace(1.0,  2.0, num &#x3D;  3) </span><br><span class="line">a</span><br><span class="line">Out[22]: array([ 10.       ,  31.6227766, 100.       ])</span><br><span class="line">a &#x3D; np.logspace(1.0,  3.0, num &#x3D;  3) </span><br><span class="line">a</span><br><span class="line">Out[24]: array([  10.,  100., 1000.])</span><br><span class="line">a &#x3D; np.logspace(1.0,  4.0, num &#x3D;  3) </span><br><span class="line">a</span><br><span class="line">Out[26]: array([   10.        ,   316.22776602, 10000.        ])</span><br></pre></td></tr></table></figure>

<p>切片的大部分步骤和列表切片一致.但切片可以使用省略号,将返回包含元素的数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;np.array([[1,2,3],[4,5,6],[7,8,9]])</span><br><span class="line">a</span><br><span class="line">Out[29]: </span><br><span class="line">array([[1, 2, 3],</span><br><span class="line">       [4, 5, 6],</span><br><span class="line">       [7, 8, 9]])</span><br><span class="line">a[...,1]</span><br><span class="line">Out[30]: array([2, 5, 8])</span><br><span class="line">a[...,2]</span><br><span class="line">Out[31]: array([3, 6, 9])</span><br><span class="line">a[...,1:]</span><br><span class="line">Out[33]: </span><br><span class="line">array([[2, 3],</span><br><span class="line">       [5, 6],</span><br><span class="line">       [8, 9]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>numpy还提供了一些更加高级的索引形式<br>获取[0,0],[1,1],[2,0]位置处的元素可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; np.array([[1,  2],  [3,  4],  [5,  6]]) </span><br><span class="line">y &#x3D; x[[0,1,2],  [0,1,0]]  </span><br><span class="line">y</span><br><span class="line">Out[35]: array([1, 4, 5])</span><br></pre></td></tr></table></figure>

<p>也有布尔索引,~可以取补</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">Out[44]: </span><br><span class="line">array([[1, 2, 3],</span><br><span class="line">       [4, 5, 6],</span><br><span class="line">       [7, 8, 9]])</span><br><span class="line">a[a&gt;5]</span><br><span class="line">Out[45]: array([6, 7, 8, 9])</span><br><span class="line"></span><br><span class="line">a[~(a&gt;5)]</span><br><span class="line">Out[49]: array([1, 2, 3, 4, 5])</span><br></pre></td></tr></table></figure>

<h4 id="numpy广播"><a href="#numpy广播" class="headerlink" title="numpy广播"></a>numpy广播</h4><p>广播通常用于对不同形状的数组进行运算.</p>
<p>如果两个数组的形状相同,则对对应形状上的元素直接运算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">Out[52]: [[1, 2, 3], [2, 3, 4]]</span><br><span class="line">b</span><br><span class="line">Out[53]: [[4, 5, 6], [7, 8, 9]]</span><br><span class="line"></span><br><span class="line">a&#x3D;np.array(a)</span><br><span class="line">b&#x3D;np.array(b)</span><br><span class="line">a*b</span><br><span class="line">Out[57]: </span><br><span class="line">array([[ 4, 10, 18],</span><br><span class="line">       [14, 24, 36]])</span><br></pre></td></tr></table></figure>

<p>如果形状不同会触发广播机制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; np.array([[ 0, 0, 0],</span><br><span class="line">           [10,10,10],</span><br><span class="line">           [20,20,20],</span><br><span class="line">           [30,30,30]])</span><br><span class="line">b &#x3D; np.array([1,2,3])</span><br><span class="line">a+b</span><br><span class="line">Out[60]: </span><br><span class="line">array([[ 1,  2,  3],</span><br><span class="line">       [11, 12, 13],</span><br><span class="line">       [21, 22, 23],</span><br><span class="line">       [31, 32, 33]])</span><br><span class="line">a*b</span><br><span class="line">Out[61]: </span><br><span class="line">array([[ 0,  0,  0],</span><br><span class="line">       [10, 20, 30],</span><br><span class="line">       [20, 40, 60],</span><br><span class="line">       [30, 60, 90]])</span><br></pre></td></tr></table></figure>

<p>广播的规则:</p>
<p>让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在前面加 1 补齐。<br>输出数组的形状是输入数组形状的各个维度上的最大值。<br>如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错。<br>当输入数组的某个维度的长度为 1 时，沿着此维度运算时都用此维度上的第一组值。</p>
<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>使用nditer可以迭代的输出其中的元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;np.arange(6).reshape(2,3)</span><br><span class="line">a</span><br><span class="line">Out[5]: </span><br><span class="line">array([[0, 1, 2],</span><br><span class="line">       [3, 4, 5]])</span><br><span class="line">for x in a:</span><br><span class="line">    print(x)</span><br><span class="line">    </span><br><span class="line">[0 1 2]</span><br><span class="line">[3 4 5]</span><br><span class="line">for x in np.nditer(a):</span><br><span class="line">    print (x, end&#x3D;&quot;, &quot; )</span><br><span class="line">    </span><br><span class="line">0, 1, 2, 3, 4, 5, </span><br></pre></td></tr></table></figure>

<p>对于ndtier,他会默认以行优先输出,当设置矩阵的存储格式是行优先时,迭代会正确的完成,若为列优先,迭代结果会变为按列来.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for x in np.nditer(a):</span><br><span class="line">    print (x, end&#x3D;&quot;, &quot; )</span><br><span class="line">    </span><br><span class="line">0, 1, 2, 3, 4, 5, In[8]: import numpy as np</span><br><span class="line">a &#x3D; np.arange(0, 60, 5)</span><br><span class="line">a &#x3D; a.reshape(3, 4)</span><br><span class="line">print(&#39;原始数组是：&#39;)</span><br><span class="line">print(a)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;原始数组的转置是：&#39;)</span><br><span class="line">b &#x3D; a.T</span><br><span class="line">print(b)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;以 C 风格顺序排序：&#39;)</span><br><span class="line">c &#x3D; b.copy(order&#x3D;&#39;C&#39;)</span><br><span class="line">print(c)</span><br><span class="line">for x in np.nditer(c):</span><br><span class="line">    print(x, end&#x3D;&quot;, &quot;)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;以 F 风格顺序排序：&#39;)</span><br><span class="line">c &#x3D; b.copy(order&#x3D;&#39;F&#39;)</span><br><span class="line">print(c)</span><br><span class="line">for x in np.nditer(c):</span><br><span class="line">    print(x, end&#x3D;&quot;, &quot;)</span><br><span class="line">    </span><br><span class="line">原始数组是：</span><br><span class="line">[[ 0  5 10 15]</span><br><span class="line"> [20 25 30 35]</span><br><span class="line"> [40 45 50 55]]</span><br><span class="line">原始数组的转置是：</span><br><span class="line">[[ 0 20 40]</span><br><span class="line"> [ 5 25 45]</span><br><span class="line"> [10 30 50]</span><br><span class="line"> [15 35 55]]</span><br><span class="line">以 C 风格顺序排序：</span><br><span class="line">[[ 0 20 40]</span><br><span class="line"> [ 5 25 45]</span><br><span class="line"> [10 30 50]</span><br><span class="line"> [15 35 55]]</span><br><span class="line">0, 20, 40, 5, 25, 45, 10, 30, 50, 15, 35, 55, </span><br><span class="line">以 F 风格顺序排序：</span><br><span class="line">[[ 0 20 40]</span><br><span class="line"> [ 5 25 45]</span><br><span class="line"> [10 30 50]</span><br><span class="line"> [15 35 55]]</span><br><span class="line">0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, </span><br></pre></td></tr></table></figure>

<p>修改元素值,nditer中有参数op_flags可以控制是否修改值<br>另,x[…] 是修改原 numpy 元素，x 只是个拷贝。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; np.arange(0,60,5) </span><br><span class="line">a &#x3D; a.reshape(3,4)  </span><br><span class="line">print (&#39;原始数组是：&#39;)</span><br><span class="line">print (a)</span><br><span class="line">print (&#39;\n&#39;)</span><br><span class="line">for x in np.nditer(a, op_flags&#x3D;[&#39;readwrite&#39;]): </span><br><span class="line">    x[...]&#x3D;2*x </span><br><span class="line">print (&#39;修改后的数组是：&#39;)</span><br><span class="line">print (a)</span><br><span class="line">原始数组是：</span><br><span class="line">[[ 0  5 10 15]</span><br><span class="line"> [20 25 30 35]</span><br><span class="line"> [40 45 50 55]]</span><br><span class="line">修改后的数组是：</span><br><span class="line">[[  0  10  20  30]</span><br><span class="line"> [ 40  50  60  70]</span><br><span class="line"> [ 80  90 100 110]]</span><br></pre></td></tr></table></figure>

<p>迭代同时也是可以进行广播的<br>同属对两个矩阵迭代,会自动执行类似运算时出现的广播</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; np.arange(0,60,5) </span><br><span class="line">a &#x3D; a.reshape(3,4)  </span><br><span class="line">print  (&#39;第一个数组为：&#39;)</span><br><span class="line">print (a)</span><br><span class="line">print  (&#39;\n&#39;)</span><br><span class="line">print (&#39;第二个数组为：&#39;)</span><br><span class="line">b &#x3D; np.array([1,  2,  3,  4], dtype &#x3D;  int)  </span><br><span class="line">print (b)</span><br><span class="line">print (&#39;\n&#39;)</span><br><span class="line">print (&#39;广播输出为：&#39;)</span><br><span class="line">for x,y in np.nditer([a,b]):  </span><br><span class="line">    print (&quot;%d:%d&quot;  %  (x,y), end&#x3D;&quot;, &quot; )</span><br><span class="line">    </span><br><span class="line">第一个数组为：</span><br><span class="line">[[ 0  5 10 15]</span><br><span class="line"> [20 25 30 35]</span><br><span class="line"> [40 45 50 55]]</span><br><span class="line">第二个数组为：</span><br><span class="line">[1 2 3 4]</span><br><span class="line">广播输出为：</span><br><span class="line">0:1, 5:2, 10:3, 15:4, 20:1, 25:2, 30:3, 35:4, 40:1, 45:2, 50:3, 55:4, </span><br></pre></td></tr></table></figure>


<h4 id="numpy数组操作"><a href="#numpy数组操作" class="headerlink" title="numpy数组操作"></a>numpy数组操作</h4><p>这是核心也是最常用的部分啦,一定要好好学!</p>
<h5 id="reshape"><a href="#reshape" class="headerlink" title="reshape"></a>reshape</h5><p>reshape可以在不改变数据的条件下修改形状,参数可以设置order,一般只调整格式就好</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&#39;原始数组：&#39;)</span><br><span class="line">print(a)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">b &#x3D; a.reshape(4, 2)</span><br><span class="line">print(&#39;修改后的数组：&#39;)</span><br><span class="line">print(b)</span><br><span class="line">原始数组：</span><br><span class="line">[0 1 2 3 4 5 6 7]</span><br><span class="line">修改后的数组：</span><br><span class="line">[[0 1]</span><br><span class="line"> [2 3]</span><br><span class="line"> [4 5]</span><br><span class="line"> </span><br><span class="line">#这样也可以:</span><br><span class="line">np.reshape(a,(2,4))</span><br><span class="line">Out[18]: </span><br><span class="line">array([[0, 1, 2, 3],</span><br><span class="line">       [4, 5, 6, 7]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="numpy-ndarray-flat"><a href="#numpy-ndarray-flat" class="headerlink" title="numpy.ndarray.flat"></a>numpy.ndarray.flat</h5><p>是一个迭代器,直接可以返回里面的所有数据元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for x in a.flat:</span><br><span class="line">    print(x)</span><br><span class="line">    </span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="numpy-ndarray-flatten"><a href="#numpy-ndarray-flatten" class="headerlink" title="numpy.ndarray.flatten"></a>numpy.ndarray.flatten</h5><p>将数组转换为一个维度的数组,是副本，并返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; np.arange(8).reshape(2, 4)</span><br><span class="line">print(&#39;原数组：&#39;)</span><br><span class="line">print(a)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line"># 默认按行</span><br><span class="line">print(&#39;展开的数组：&#39;)</span><br><span class="line">print(a.flatten())</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;以 F 风格顺序展开的数组：&#39;)</span><br><span class="line">print(a.flatten(order&#x3D;&#39;F&#39;))</span><br><span class="line">原数组：</span><br><span class="line">[[0 1 2 3]</span><br><span class="line"> [4 5 6 7]]</span><br><span class="line">展开的数组：</span><br><span class="line">[0 1 2 3 4 5 6 7]</span><br><span class="line">以 F 风格顺序展开的数组：</span><br><span class="line">[0 4 1 5 2 6 3 7]</span><br></pre></td></tr></table></figure>

<h5 id="numpy-ravel"><a href="#numpy-ravel" class="headerlink" title="numpy.ravel"></a>numpy.ravel</h5><p>也是展平,但返回的不是拷贝,是视图.所以对它的修改会影响原数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; np.arange(8).reshape(2, 4)</span><br><span class="line">print(&#39;原数组：&#39;)</span><br><span class="line">print(a)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;调用 ravel 函数之后：&#39;)</span><br><span class="line">b&#x3D;a.ravel()</span><br><span class="line">print(b)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">原数组：</span><br><span class="line">[[0 1 2 3]</span><br><span class="line"> [4 5 6 7]]</span><br><span class="line">调用 ravel 函数之后：</span><br><span class="line">[0 1 2 3 4 5 6 7]</span><br><span class="line">b</span><br><span class="line">Out[28]: array([0, 1, 2, 3, 4, 5, 6, 7])</span><br><span class="line">b[0]&#x3D;2</span><br><span class="line">a</span><br><span class="line">Out[30]: </span><br><span class="line">array([[2, 1, 2, 3],</span><br><span class="line">       [4, 5, 6, 7]])</span><br></pre></td></tr></table></figure>

<h5 id="numpy-transpose和numpy-ndarray-T"><a href="#numpy-transpose和numpy-ndarray-T" class="headerlink" title="numpy.transpose和numpy.ndarray.T"></a>numpy.transpose和numpy.ndarray.T</h5><p>就是对数组求转置,不改变数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">Out[31]: </span><br><span class="line">array([[2, 1, 2, 3],</span><br><span class="line">       [4, 5, 6, 7]])</span><br><span class="line">a.T</span><br><span class="line">Out[32]: </span><br><span class="line">array([[2, 4],</span><br><span class="line">       [1, 5],</span><br><span class="line">       [2, 6],</span><br><span class="line">       [3, 7]])</span><br><span class="line">a</span><br><span class="line">Out[33]: </span><br><span class="line">array([[2, 1, 2, 3],</span><br><span class="line">       [4, 5, 6, 7]])</span><br><span class="line">np.transpose(a)</span><br><span class="line">Out[34]: </span><br><span class="line">array([[2, 4],</span><br><span class="line">       [1, 5],</span><br><span class="line">       [2, 6],</span><br><span class="line">       [3, 7]])</span><br></pre></td></tr></table></figure>

<h5 id="numpy-rollaxis"><a href="#numpy-rollaxis" class="headerlink" title="numpy.rollaxis"></a>numpy.rollaxis</h5><p>可以针对某一轴进行向后的滚动,就是把一个轴滚动到相应位置,所有轴的相对位置不变,选定轴和选定滚的位置实际上就是为了确定滚得距离.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建了三维的 ndarray</span><br><span class="line">a &#x3D; np.arange(8).reshape(2, 2, 2)</span><br><span class="line">print(&#39;原数组：&#39;)</span><br><span class="line">print(a)</span><br><span class="line">print(&#39;获取数组中一个值：&#39;)</span><br><span class="line">print(np.where(a &#x3D;&#x3D; 6))</span><br><span class="line">print(a[1, 1, 0])  # 为 6</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line"># 将轴 2 滚动到轴 0（宽度到深度）</span><br><span class="line">print(&#39;调用 rollaxis 函数：&#39;)</span><br><span class="line">b &#x3D; np.rollaxis(a, 2, 0)</span><br><span class="line">print(b)</span><br><span class="line"># 查看元素 a[1,1,0]，即 6 的坐标，变成 [0, 1, 1]</span><br><span class="line"># 最后一个 0 移动到最前面</span><br><span class="line">print(np.where(b &#x3D;&#x3D; 6))</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line"># 将轴 2 滚动到轴 1：（宽度到高度）</span><br><span class="line">print(&#39;调用 rollaxis 函数：&#39;)</span><br><span class="line">c &#x3D; np.rollaxis(a, 2, 1)</span><br><span class="line">print(c)</span><br><span class="line"># 查看元素 a[1,1,0]，即 6 的坐标，变成 [1, 0, 1]</span><br><span class="line"># 最后的 0 和 它前面的 1 对换位置</span><br><span class="line">print(np.where(c &#x3D;&#x3D; 6))</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">原数组：</span><br><span class="line">[[[0 1]</span><br><span class="line">  [2 3]]</span><br><span class="line"> [[4 5]</span><br><span class="line">  [6 7]]]</span><br><span class="line">获取数组中一个值：</span><br><span class="line">(array([1], dtype&#x3D;int64), array([1], dtype&#x3D;int64), array([0], dtype&#x3D;int64))</span><br><span class="line">6</span><br><span class="line">调用 rollaxis 函数：</span><br><span class="line">[[[0 2]</span><br><span class="line">  [4 6]]</span><br><span class="line"> [[1 3]</span><br><span class="line">  [5 7]]]</span><br><span class="line">(array([0], dtype&#x3D;int64), array([1], dtype&#x3D;int64), array([1], dtype&#x3D;int64))</span><br><span class="line">调用 rollaxis 函数：</span><br><span class="line">[[[0 2]</span><br><span class="line">  [1 3]]</span><br><span class="line"> [[4 6]</span><br><span class="line">  [5 7]]]</span><br><span class="line">(array([1], dtype&#x3D;int64), array([0], dtype&#x3D;int64), array([1], dtype&#x3D;int64))</span><br></pre></td></tr></table></figure>

<h5 id="numpy-swapaxes"><a href="#numpy-swapaxes" class="headerlink" title="numpy.swapaxes"></a>numpy.swapaxes</h5><p>即为交换两个轴的位置</p>
<h5 id="numpy-broadcast"><a href="#numpy-broadcast" class="headerlink" title="numpy.broadcast"></a>numpy.broadcast</h5><p>以广播的方式去扩充一个数组到希望的维度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; np.array([[1], [2], [3]])</span><br><span class="line">y &#x3D; np.array([4, 5, 6])</span><br><span class="line"># 对 y 广播 x</span><br><span class="line">b &#x3D; np.broadcast(x, y)</span><br><span class="line"># 它拥有 iterator 属性，基于自身组件的迭代器元组</span><br><span class="line">print(&#39;对 y 广播 x：&#39;)</span><br><span class="line">r, c &#x3D; b.iters</span><br><span class="line"># Python3.x 为 next(context) ，Python2.x 为 context.next()</span><br><span class="line">print(next(r), next(c))</span><br><span class="line">print(next(r), next(c))</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line"># shape 属性返回广播对象的形状</span><br><span class="line">print(&#39;广播对象的形状：&#39;)</span><br><span class="line">print(b.shape)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line"># 手动使用 broadcast 将 x 与 y 相加</span><br><span class="line">b &#x3D; np.broadcast(x, y)</span><br><span class="line">c &#x3D; np.empty(b.shape)</span><br><span class="line">print(&#39;手动使用 broadcast 将 x 与 y 相加：&#39;)</span><br><span class="line">print(c.shape)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">c.flat &#x3D; [u + v for (u, v) in b]</span><br><span class="line">print(&#39;调用 flat 函数：&#39;)</span><br><span class="line">print(c)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line"># 获得了和 NumPy 内建的广播支持相同的结果</span><br><span class="line">print(&#39;x 与 y 的和：&#39;)</span><br><span class="line">print(x + y)</span><br><span class="line">对 y 广播 x：</span><br><span class="line">1 4</span><br><span class="line">1 5</span><br><span class="line">广播对象的形状：</span><br><span class="line">(3, 3)</span><br><span class="line">手动使用 broadcast 将 x 与 y 相加：</span><br><span class="line">(3, 3)</span><br><span class="line">调用 flat 函数：</span><br><span class="line">[[5. 6. 7.]</span><br><span class="line"> [6. 7. 8.]</span><br><span class="line"> [7. 8. 9.]]</span><br><span class="line">x 与 y 的和：</span><br><span class="line">[[5 6 7]</span><br><span class="line"> [6 7 8]</span><br><span class="line"> [7 8 9]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="numpy-broadcast-to"><a href="#numpy-broadcast-to" class="headerlink" title="numpy.broadcast_to"></a>numpy.broadcast_to</h5><p>将数组广播到新形状。它在原始数组上返回只读视图。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; np.arange(4).reshape(1, 4)</span><br><span class="line">print(&#39;原数组：&#39;)</span><br><span class="line">print(a)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;调用 broadcast_to 函数之后：&#39;)</span><br><span class="line">print(np.broadcast_to(a, (4, 4)))</span><br><span class="line">原数组：</span><br><span class="line">[[0 1 2 3]]</span><br><span class="line">调用 broadcast_to 函数之后：</span><br><span class="line">[[0 1 2 3]</span><br><span class="line"> [0 1 2 3]</span><br><span class="line"> [0 1 2 3]</span><br><span class="line"> [0 1 2 3]]</span><br></pre></td></tr></table></figure>

<h5 id="numpy-expand-dims"><a href="#numpy-expand-dims" class="headerlink" title="numpy.expand_dims"></a>numpy.expand_dims</h5><p>过在指定位置插入新的轴来扩展数组形状</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; np.array(([1, 2], [3, 4]))</span><br><span class="line">print(&#39;数组 x：&#39;)</span><br><span class="line">print(x)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">y &#x3D; np.expand_dims(x, axis&#x3D;0)</span><br><span class="line">print(&#39;数组 y：&#39;)</span><br><span class="line">print(y)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;数组 x 和 y 的形状：&#39;)</span><br><span class="line">print(x.shape, y.shape)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line"># 在位置 1 插入轴</span><br><span class="line">y &#x3D; np.expand_dims(x, axis&#x3D;1)</span><br><span class="line">print(&#39;在位置 1 插入轴之后的数组 y：&#39;)</span><br><span class="line">print(y)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;x.ndim 和 y.ndim：&#39;)</span><br><span class="line">print(x.ndim, y.ndim)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;x.shape 和 y.shape：&#39;)</span><br><span class="line">print(x.shape, y.shape)</span><br><span class="line"></span><br><span class="line">数组 x：</span><br><span class="line">[[1 2]</span><br><span class="line"> [3 4]]</span><br><span class="line">数组 y：</span><br><span class="line">[[[1 2]</span><br><span class="line">  [3 4]]]</span><br><span class="line">数组 x 和 y 的形状：</span><br><span class="line">(2, 2) (1, 2, 2)</span><br><span class="line">在位置 1 插入轴之后的数组 y：</span><br><span class="line">[[[1 2]]</span><br><span class="line"> [[3 4]]]</span><br><span class="line">x.ndim 和 y.ndim：</span><br><span class="line">2 3</span><br><span class="line">x.shape 和 y.shape：</span><br><span class="line">(2, 2) (2, 1, 2)</span><br></pre></td></tr></table></figure>

<h5 id="numpy-squeeze"><a href="#numpy-squeeze" class="headerlink" title="numpy.squeeze"></a>numpy.squeeze</h5><p>从给定数组的形状中删除一维的条目,只能删除一维的条目!</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; np.arange(9).reshape(1, 3, 3)</span><br><span class="line">print(&#39;数组 x：&#39;)</span><br><span class="line">print(x)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">y &#x3D; np.squeeze(x)</span><br><span class="line">print(&#39;数组 y：&#39;)</span><br><span class="line">print(y)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;数组 x 和 y 的形状：&#39;)</span><br><span class="line">print(x.shape, y.shape)</span><br><span class="line">数组 x：</span><br><span class="line">[[[0 1 2]</span><br><span class="line">  [3 4 5]</span><br><span class="line">  [6 7 8]]]</span><br><span class="line">数组 y：</span><br><span class="line">[[0 1 2]</span><br><span class="line"> [3 4 5]</span><br><span class="line"> [6 7 8]]</span><br><span class="line">数组 x 和 y 的形状：</span><br><span class="line">(1, 3, 3) (3, 3)</span><br></pre></td></tr></table></figure>

<h5 id="numpy-concatenate"><a href="#numpy-concatenate" class="headerlink" title="numpy.concatenate"></a>numpy.concatenate</h5><p>沿指定轴连接相同形状的两个或多个数组,默认维度为零</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; np.array([[1, 2], [3, 4]])</span><br><span class="line">print(&#39;第一个数组：&#39;)</span><br><span class="line">print(a)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">b &#x3D; np.array([[5, 6], [7, 8]])</span><br><span class="line">print(&#39;第二个数组：&#39;)</span><br><span class="line">print(b)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line"># 两个数组的维度相同</span><br><span class="line">print(&#39;沿轴 0 连接两个数组：&#39;)</span><br><span class="line">print(np.concatenate((a, b)))</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;沿轴 1 连接两个数组：&#39;)</span><br><span class="line">print(np.concatenate((a, b), axis&#x3D;1))</span><br><span class="line">第一个数组：</span><br><span class="line">[[1 2]</span><br><span class="line"> [3 4]]</span><br><span class="line">第二个数组：</span><br><span class="line">[[5 6]</span><br><span class="line"> [7 8]]</span><br><span class="line">沿轴 0 连接两个数组：</span><br><span class="line">[[1 2]</span><br><span class="line"> [3 4]</span><br><span class="line"> [5 6]</span><br><span class="line"> [7 8]]</span><br><span class="line">沿轴 1 连接两个数组：</span><br><span class="line">[[1 2 5 6]</span><br><span class="line"> [3 4 7 8]]</span><br></pre></td></tr></table></figure>
<h5 id="numpy-stack"><a href="#numpy-stack" class="headerlink" title="numpy.stack"></a>numpy.stack</h5><p>沿新轴连接数组序列,要求数组的格式相同,可以选择堆叠维度,可以对多个数组进行操作</p>
<p>上一个concatenate函数是在已有维度上连接,stack在新的维度上进行了堆叠.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; np.array([[1, 2], [3, 4]])</span><br><span class="line">print(&#39;第一个数组：&#39;)</span><br><span class="line">print(a)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">b &#x3D; np.array([[5, 6], [7, 8]])</span><br><span class="line">print(&#39;第二个数组：&#39;)</span><br><span class="line">print(b)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;沿轴 0 堆叠两个数组：&#39;)</span><br><span class="line">print(np.stack((a, b), 0))</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;沿轴 1 堆叠两个数组：&#39;)</span><br><span class="line">print(np.stack((a, b), 1))</span><br><span class="line">第一个数组：</span><br><span class="line">[[1 2]</span><br><span class="line"> [3 4]]</span><br><span class="line">第二个数组：</span><br><span class="line">[[5 6]</span><br><span class="line"> [7 8]]</span><br><span class="line">沿轴 0 堆叠两个数组：</span><br><span class="line">[[[1 2]</span><br><span class="line">  [3 4]]</span><br><span class="line"> [[5 6]</span><br><span class="line">  [7 8]]]</span><br><span class="line">沿轴 1 堆叠两个数组：</span><br><span class="line">[[[1 2]</span><br><span class="line">  [5 6]]</span><br><span class="line"> [[3 4]</span><br><span class="line">  [7 8]]]</span><br></pre></td></tr></table></figure>

<h5 id="numpy-hstack"><a href="#numpy-hstack" class="headerlink" title="numpy.hstack"></a>numpy.hstack</h5><p>numpy.stack 函数的变体，它通过水平连接来生成数组。要求除第二个轴外其他轴形状相同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; np.array([[1, 2], [3, 4]])</span><br><span class="line">print(&#39;第一个数组：&#39;)</span><br><span class="line">print(a)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">b &#x3D; np.array([[5, 6], [7, 8]])</span><br><span class="line">print(&#39;第二个数组：&#39;)</span><br><span class="line">print(b)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;水平堆叠：&#39;)</span><br><span class="line">c &#x3D; np.hstack((a, b))</span><br><span class="line">print(c)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">第一个数组：</span><br><span class="line">[[1 2]</span><br><span class="line"> [3 4]]</span><br><span class="line">第二个数组：</span><br><span class="line">[[5 6]</span><br><span class="line"> [7 8]]</span><br><span class="line">水平堆叠：</span><br><span class="line">[[1 2 5 6]</span><br><span class="line"> [3 4 7 8]]</span><br></pre></td></tr></table></figure>

<h5 id="numpy-vstack"><a href="#numpy-vstack" class="headerlink" title="numpy.vstack"></a>numpy.vstack</h5><p>同样是变体,通过垂直重叠来连接.除第一个维度外其他维度各市要相同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; np.array([[1, 2], [3, 4],[11,12]])</span><br><span class="line">print(&#39;第一个数组：&#39;)</span><br><span class="line">print(a)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">b &#x3D; np.array([[5, 6], [7, 8]])</span><br><span class="line">print(&#39;第二个数组：&#39;)</span><br><span class="line">print(b)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;竖直堆叠：&#39;)</span><br><span class="line">c &#x3D; np.vstack((a, b))</span><br><span class="line">print(c)</span><br><span class="line">第一个数组：</span><br><span class="line">[[ 1  2]</span><br><span class="line"> [ 3  4]</span><br><span class="line"> [11 12]]</span><br><span class="line">第二个数组：</span><br><span class="line">[[5 6]</span><br><span class="line"> [7 8]]</span><br><span class="line">竖直堆叠：</span><br><span class="line">[[ 1  2]</span><br><span class="line"> [ 3  4]</span><br><span class="line"> [11 12]</span><br><span class="line"> [ 5  6]</span><br><span class="line"> [ 7  8]]</span><br></pre></td></tr></table></figure>

<h5 id="numpy-split"><a href="#numpy-split" class="headerlink" title="numpy.split"></a>numpy.split</h5><p>特定的轴将数组分割为子数组.参数指明分割的数组,分割的方式和分割的维度.分割的方式为整数时表示将数组平均分成几份,为列表时表示在那几个位置进行分割.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; np.arange(9)</span><br><span class="line">print(&#39;第一个数组：&#39;)</span><br><span class="line">print(a)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;将数组分为三个大小相等的子数组：&#39;)</span><br><span class="line">b &#x3D; np.split(a, 3)</span><br><span class="line">print(b)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;将数组在一维数组中表明的位置分割：&#39;)</span><br><span class="line">b &#x3D; np.split(a, [4, 7])</span><br><span class="line">print(b)</span><br><span class="line">第一个数组：</span><br><span class="line">[0 1 2 3 4 5 6 7 8]</span><br><span class="line">将数组分为三个大小相等的子数组：</span><br><span class="line">[array([0, 1, 2]), array([3, 4, 5]), array([6, 7, 8])]</span><br><span class="line">将数组在一维数组中表明的位置分割：</span><br><span class="line">[array([0, 1, 2, 3]), array([4, 5, 6]), array([7, 8])]</span><br></pre></td></tr></table></figure>

<p>默认水平分割,在参数为1时进行垂直分割</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; np.arange(16).reshape(4, 4)</span><br><span class="line">print(&#39;第一个数组：&#39;)</span><br><span class="line">print(a)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;默认分割（0轴）：&#39;)</span><br><span class="line">b &#x3D; np.split(a,2)</span><br><span class="line">print(b)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;沿垂直方向分割：&#39;)</span><br><span class="line">c &#x3D; np.split(a,2,1)</span><br><span class="line">print(c)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line"></span><br><span class="line">第一个数组：</span><br><span class="line">[[ 0  1  2  3]</span><br><span class="line"> [ 4  5  6  7]</span><br><span class="line"> [ 8  9 10 11]</span><br><span class="line"> [12 13 14 15]]</span><br><span class="line">默认分割（0轴）：</span><br><span class="line">[array([[0, 1, 2, 3],</span><br><span class="line">       [4, 5, 6, 7]]), array([[ 8,  9, 10, 11],</span><br><span class="line">       [12, 13, 14, 15]])]</span><br><span class="line">沿垂直方向分割：</span><br><span class="line">[array([[ 0,  1],</span><br><span class="line">       [ 4,  5],</span><br><span class="line">       [ 8,  9],</span><br><span class="line">       [12, 13]]), array([[ 2,  3],</span><br><span class="line">       [ 6,  7],</span><br><span class="line">       [10, 11],</span><br><span class="line">       [14, 15]])]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="numpy-hsplit"><a href="#numpy-hsplit" class="headerlink" title="numpy.hsplit"></a>numpy.hsplit</h5><p>水平分割数组,指定分割份数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">harr &#x3D; np.floor(10 * np.random.random((2, 6)))</span><br><span class="line">print(&#39;原array：&#39;)</span><br><span class="line">print(harr)</span><br><span class="line">print(&#39;拆分后：&#39;)</span><br><span class="line">print(np.hsplit(harr, 3))</span><br><span class="line">原array：</span><br><span class="line">[[1. 1. 6. 8. 7. 3.]</span><br><span class="line"> [8. 0. 3. 2. 3. 5.]]</span><br><span class="line">拆分后：</span><br><span class="line">[array([[1., 1.],</span><br><span class="line">       [8., 0.]]), array([[6., 8.],</span><br><span class="line">       [3., 2.]]), array([[7., 3.],</span><br><span class="line">       [3., 5.]])]</span><br></pre></td></tr></table></figure>

<h5 id="numpy-vsplit"><a href="#numpy-vsplit" class="headerlink" title="numpy.vsplit"></a>numpy.vsplit</h5><p>竖直分割数组,指定分割份数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; np.arange(16).reshape(4, 4)</span><br><span class="line">print(&#39;第一个数组：&#39;)</span><br><span class="line">print(a)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;竖直分割：&#39;)</span><br><span class="line">b &#x3D; np.vsplit(a, 2)</span><br><span class="line">print(b)</span><br><span class="line">第一个数组：</span><br><span class="line">[[ 0  1  2  3]</span><br><span class="line"> [ 4  5  6  7]</span><br><span class="line"> [ 8  9 10 11]</span><br><span class="line"> [12 13 14 15]]</span><br><span class="line">竖直分割：</span><br><span class="line">[array([[0, 1, 2, 3],</span><br><span class="line">       [4, 5, 6, 7]]), array([[ 8,  9, 10, 11],</span><br><span class="line">       [12, 13, 14, 15]])]</span><br></pre></td></tr></table></figure>

<h5 id="numpy-resize"><a href="#numpy-resize" class="headerlink" title="numpy.resize"></a>numpy.resize</h5><p>回指定大小的新数组。如果新数组大小大于原始大小，则包含原始数组中的元素的副本。注意是resize不是reshape!</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; np.array([[1, 2, 3], [4, 5, 6]])</span><br><span class="line">print(&#39;第一个数组：&#39;)</span><br><span class="line">print(a)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;第一个数组的形状：&#39;)</span><br><span class="line">print(a.shape)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">b &#x3D; np.resize(a, (3, 20))</span><br><span class="line">print(&#39;第二个数组：&#39;)</span><br><span class="line">print(b)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;第二个数组的形状：&#39;)</span><br><span class="line">print(b.shape)</span><br><span class="line">第一个数组：</span><br><span class="line">[[1 2 3]</span><br><span class="line"> [4 5 6]]</span><br><span class="line">第一个数组的形状：</span><br><span class="line">(2, 3)</span><br><span class="line">第二个数组：</span><br><span class="line">[[1 2 3 4 5 6 1 2 3 4 5 6 1 2 3 4 5 6 1 2]</span><br><span class="line"> [3 4 5 6 1 2 3 4 5 6 1 2 3 4 5 6 1 2 3 4]</span><br><span class="line"> [5 6 1 2 3 4 5 6 1 2 3 4 5 6 1 2 3 4 5 6]]</span><br><span class="line">第二个数组的形状：</span><br><span class="line">(3, 20)</span><br></pre></td></tr></table></figure>
<p>resize可以进行扩张也可以进行缩小</p>
<h5 id="numpy-append"><a href="#numpy-append" class="headerlink" title="numpy.append"></a>numpy.append</h5><p>给数组在尾部添加值,可以通过axis的参数调整值的形状</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; np.array([[1, 2, 3], [4, 5, 6]])</span><br><span class="line">print(&#39;第一个数组：&#39;)</span><br><span class="line">print(a)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;向数组添加元素：&#39;)</span><br><span class="line">print(np.append(a, [7, 8, 9]))</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;沿轴 0 添加元素：&#39;)</span><br><span class="line">print(np.append(a, [[7, 8, 9]], axis&#x3D;0))</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;沿轴 1 添加元素：&#39;)</span><br><span class="line">print(np.append(a, [[5, 5, 5], [7, 8, 9]], axis&#x3D;1))</span><br><span class="line">第一个数组：</span><br><span class="line">[[1 2 3]</span><br><span class="line"> [4 5 6]]</span><br><span class="line">向数组添加元素：</span><br><span class="line">[1 2 3 4 5 6 7 8 9]</span><br><span class="line">沿轴 0 添加元素：</span><br><span class="line">[[1 2 3]</span><br><span class="line"> [4 5 6]</span><br><span class="line"> [7 8 9]]</span><br><span class="line">沿轴 1 添加元素：</span><br><span class="line">[[1 2 3 5 5 5]</span><br><span class="line"> [4 5 6 7 8 9]]</span><br></pre></td></tr></table></figure>

<h5 id="numpy-insert"><a href="#numpy-insert" class="headerlink" title="numpy.insert"></a>numpy.insert</h5><p>在给定索引之前，沿给定轴在输入数组中插入值.<br>如果值的类型转换为要插入，则它与输入数组不同。 如果未提供轴，则输入数组会被展开。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&#39;第一个数组：&#39;)</span><br><span class="line">print(a)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;未传递 Axis 参数。 在插入之前输入数组会被展开。&#39;)</span><br><span class="line">print(np.insert(a, 3, [11, 12]))</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;传递了 Axis 参数。 会广播值数组来配输入数组。&#39;)</span><br><span class="line">print(&#39;沿轴 0 广播：&#39;)</span><br><span class="line">print(np.insert(a, 1, [11], axis&#x3D;0))</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;沿轴 1 广播：&#39;)</span><br><span class="line">print(np.insert(a, 1, 11, axis&#x3D;1))</span><br><span class="line">第一个数组：</span><br><span class="line">[[1 2 3]</span><br><span class="line"> [4 5 6]]</span><br><span class="line">未传递 Axis 参数。 在插入之前输入数组会被展开。</span><br><span class="line">[ 1  2  3 11 12  4  5  6]</span><br><span class="line">传递了 Axis 参数。 会广播值数组来配输入数组。</span><br><span class="line">沿轴 0 广播：</span><br><span class="line">[[ 1  2  3]</span><br><span class="line"> [11 11 11]</span><br><span class="line"> [ 4  5  6]]</span><br><span class="line">沿轴 1 广播：</span><br><span class="line">[[ 1 11  2  3]</span><br><span class="line"> [ 4 11  5  6]]</span><br></pre></td></tr></table></figure>
<h5 id="numpy-delete"><a href="#numpy-delete" class="headerlink" title="numpy.delete"></a>numpy.delete</h5><p>返回从输入数组中删除指定子数组的新数组,如果未提供轴参数，则输入数组将展开.指定范围可以为切片，整数或者整数数组，表明要从输入数组删除的子数组.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; np.arange(12).reshape(3, 4)</span><br><span class="line">print(&#39;第一个数组：&#39;)</span><br><span class="line">print(a)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;未传递 Axis 参数。 在插入之前输入数组会被展开。&#39;)</span><br><span class="line">print(np.delete(a, 5))</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;删除第二列：&#39;)</span><br><span class="line">print(np.delete(a, 1, axis&#x3D;1))</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;包含从数组中删除的替代值的切片：&#39;)</span><br><span class="line">a &#x3D; np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])</span><br><span class="line">print(np.delete(a, np.s_[::2]))</span><br><span class="line">第一个数组：</span><br><span class="line">[[ 0  1  2  3]</span><br><span class="line"> [ 4  5  6  7]</span><br><span class="line"> [ 8  9 10 11]]</span><br><span class="line">未传递 Axis 参数。 在插入之前输入数组会被展开。</span><br><span class="line">[ 0  1  2  3  4  6  7  8  9 10 11]</span><br><span class="line">删除第二列：</span><br><span class="line">[[ 0  2  3]</span><br><span class="line"> [ 4  6  7]</span><br><span class="line"> [ 8 10 11]]</span><br><span class="line">包含从数组中删除的替代值的切片：</span><br><span class="line">[ 2  4  6  8 10]</span><br></pre></td></tr></table></figure>
<h5 id="numpy-unique"><a href="#numpy-unique" class="headerlink" title="numpy.unique"></a>numpy.unique</h5><p>用于去除数组中的重复元素。有三个布尔参数控制返回的数据是什么</p>
<p>return_index：如果为true，返回新列表元素在旧列表中的位置（下标），并以列表形式储</p>
<p>return_inverse：如果为true，返回旧列表元素在新列表中的位置（下标），并以列表形式储</p>
<p>return_counts：如果为true，返回去重数组中的元素在原数组中的出现次数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; np.array([5, 2, 6, 2, 7, 5, 6, 8, 2, 9])</span><br><span class="line">print(&#39;第一个数组：&#39;)</span><br><span class="line">print(a)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;第一个数组的去重值：&#39;)</span><br><span class="line">u &#x3D; np.unique(a)</span><br><span class="line">print(u)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;去重数组的索引数组：&#39;)</span><br><span class="line">u, indices &#x3D; np.unique(a, return_index&#x3D;True)</span><br><span class="line">print(indices)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;我们可以看到每个和原数组下标对应的数值：&#39;)</span><br><span class="line">print(a)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;去重数组的下标：&#39;)</span><br><span class="line">u, indices &#x3D; np.unique(a, return_inverse&#x3D;True)</span><br><span class="line">print(u)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;下标为：&#39;)</span><br><span class="line">print(indices)</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;使用下标重构原数组：&#39;)</span><br><span class="line">print(u[indices])</span><br><span class="line">print(&#39;\n&#39;)</span><br><span class="line">print(&#39;返回去重元素的重复数量：&#39;)</span><br><span class="line">u, indices &#x3D; np.unique(a, return_counts&#x3D;True)</span><br><span class="line">print(u)</span><br><span class="line">print(indices)</span><br><span class="line">第一个数组：</span><br><span class="line">[5 2 6 2 7 5 6 8 2 9]</span><br><span class="line">第一个数组的去重值：</span><br><span class="line">[2 5 6 7 8 9]</span><br><span class="line">去重数组的索引数组：</span><br><span class="line">[1 0 2 4 7 9]</span><br><span class="line">我们可以看到每个和原数组下标对应的数值：</span><br><span class="line">[5 2 6 2 7 5 6 8 2 9]</span><br><span class="line">去重数组的下标：</span><br><span class="line">[2 5 6 7 8 9]</span><br><span class="line">下标为：</span><br><span class="line">[1 0 2 0 3 1 2 4 0 5]</span><br><span class="line">使用下标重构原数组：</span><br><span class="line">[5 2 6 2 7 5 6 8 2 9]</span><br><span class="line">返回去重元素的重复数量：</span><br><span class="line">[2 5 6 7 8 9]</span><br><span class="line">[3 2 2 1 1 1]</span><br></pre></td></tr></table></figure>
<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>这些差不多是常用的操作啦,numpy也提供了许许多多关于计算方面的操作,在后面用到的时候在做总结!</p>
]]></content>
      <categories>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2021/04/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>昨天做了一道关于模式匹配的习题，使用正则表达式可以很快速的实现功能。正则表达式在好久之前有过接触，但一直没有系统的进行学习，今天借这个机会来总结一下！</p>
<h1 id="正则表达式的基础介绍"><a href="#正则表达式的基础介绍" class="headerlink" title="正则表达式的基础介绍"></a>正则表达式的基础介绍</h1><p>正则可以用以方便的匹配不同形式的数据，比如在输入框中匹配符合格式的手机号，身份证号以及密码，账户格式等等，且正则表达式在做数据处理时也十分常用，比如提取一个爬虫所爬出的html格式中的文件，使用正则表达式可以很方便地以易于处理的格式拿出我们需要的信息。</p>
<p>在学习中看到了推荐的两个网站，可用于后面对正则的巩固测试和练习<br><a href="https://regexr-cn.com/">https://regexr-cn.com/</a><br><br><a href="https://codejiaonang.com/">https://codejiaonang.com/</a></p>
<span id="more"></span>



<h1 id="基础学习"><a href="#基础学习" class="headerlink" title="基础学习"></a>基础学习</h1><h2 id="【】为一个字符组，用于匹配中括号中的元素任意一次"><a href="#【】为一个字符组，用于匹配中括号中的元素任意一次" class="headerlink" title="【】为一个字符组，用于匹配中括号中的元素任意一次"></a>【】为一个字符组，用于匹配中括号中的元素任意一次</h2><img src="/2021/04/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/1.jpg" class="" title="[]">

<p>在这个例子中，字符组的应用让我们同时匹配大小写的p</p>
<p>在字符组中，-可以用以表示区间</p>
<img src="/2021/04/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/2.jpg" class="" title="[]">

<p>可以发现，对于0-9都能够进行匹配<br>同理，[a-z]可以对所有小写英文字母进行匹配</p>
<p>在字符组中，如果要匹配例如-的特殊字符如-，需要使用转义/</p>
<img src="/2021/04/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/3.jpg" class="" title="[]">

<p>即为这样实现</p>
<p>^可以用以取非，即为不匹配在此字符集中的全部信息。</p>
<img src="/2021/04/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/4.jpg" class="" title="[]">

<p>当使用^时，所有字符集中原本会被匹配的字符都不再被匹配，而原本不会被匹配的部分则会被匹配。</p>
<h2 id="快捷方式"><a href="#快捷方式" class="headerlink" title="快捷方式"></a>快捷方式</h2><table>
<thead>
<tr>
<th>转义字符</th>
<th>匹配结果</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\s</td>
<td>匹配空白</td>
<td>即为匹配空格</td>
</tr>
<tr>
<td>\b</td>
<td>匹配单词边界</td>
<td>用来寻找单词的边界，一般以\bword\b的格式来使用</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字</td>
<td>与[0-9]功能一致</td>
</tr>
<tr>
<td>\w</td>
<td>匹配数字，字母，下划线</td>
<td>对这些字符进行匹配</td>
</tr>
</tbody></table>
<img src="/2021/04/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/5.jpg" class="" title="[]">

<p>应用快捷方式可以更方便的完成正则表达的匹配</p>
<p>快捷方式同样可以取反，将转移的字母改为大写即为取反。如\D 为对数字的取反</p>
<p>对于不在字符组中的^会表示从字符串开头开始匹配的意思</p>
<img src="/2021/04/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/6.jpg" class="" title="[]">

<p>在这个例子中加上了^的正则式只会匹配位于开头的python</p>
<p>相对的，$符号可以表示从字符串尾部开始匹配，同样的一个字符</p>
<img src="/2021/04/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/7.jpg" class="" title="[]">

<p>更换为$匹配的就是尾部了</p>
<h2 id="其他匹配"><a href="#其他匹配" class="headerlink" title="其他匹配"></a>其他匹配</h2><p>.可以对任意字符进行匹配</p>
<img src="/2021/04/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/8.jpg" class="" title="[]">


<p>？表示可选字符，匹配？前面的字符一次或者零次</p>
<img src="/2021/04/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/9.jpg" class="" title="[]">

<p>.？可以用于表示前面有或没有任意字符都可</p>
<img src="/2021/04/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/10.jpg" class="" title="[]">


<p>大括号可以用于匹配多个数据</p>
<img src="/2021/04/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/11.jpg" class="" title="[]">

<p>可以匹配像这样的格式</p>
<img src="/2021/04/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/12.jpg" class="" title="[]">

<img src="/2021/04/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/13.jpg" class="" title="[]">

<p>在大括号中使用逗号可以给定匹配个数的区间。如果在大括号后用问号则表示进入非贪婪模式，即为每次只匹配尽量少的长度</p>
<p>还有开闭区间的匹配</p>
<img src="/2021/04/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/14.jpg" class="" title="[]">

<p>当少写逗号后面的数字表示匹配个数以上</p>
<p>对于快速表示，+相当于{1，}而*相当于{0，}<br>可以更加方便的进行表示</p>
<img src="/2021/04/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/15.jpg" class="" title="[]">

<img src="/2021/04/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/16.jpg" class="" title="[]">


<p>凭借以上的知识，就可以写出用以验证电话号码的正则式</p>
<img src="/2021/04/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/17.jpg" class="" title="[]">

<p>同理，也能得到验证网址的正则式</p>
<img src="/2021/04/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/18.jpg" class="" title="[]">

<hr>
<p>到现在我们就完成了正则的基础部分，可以进行进阶部分的学习</p>
<h1 id="正则进阶"><a href="#正则进阶" class="headerlink" title="正则进阶"></a>正则进阶</h1><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>使用分组时，除了获得整个匹配。还能够在匹配中选择每一个分组。</p>
<img src="/2021/04/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/19.jpg" class="" title="[]">

<img src="/2021/04/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/20.jpg" class="" title="[]">

<p>使用|可以写出或者条件。<br>例如要提取所有图片文件的后缀名，可以在各个后缀名之间加上一个 |符号：</p>
<img src="/2021/04/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/21.jpg" class="" title="[]">

<p>通过上面两个例子能比较清晰的了解分组作用，至此也就具备了解决之前所做到题的能力。</p>
<p>分组也有非捕获分组</p>
<p>有时候，我们并不需要捕获某个分组的内容，但是又想使用分组的特性。<br>这个时候就可以使用非捕获组(?:表达式)，从而不捕获数据，还能使用分组的功能。</p>
<img src="/2021/04/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/22.jpg" class="" title="[]">

<p>在这个例子中第一个分组就没有被捕获。但依照它的形式能够使用或者条件，这也是分组的应用</p>
<h2 id="分组中的回溯引用"><a href="#分组中的回溯引用" class="headerlink" title="分组中的回溯引用"></a>分组中的回溯引用</h2><img src="/2021/04/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/23.jpg" class="" title="[]">

<p>通过\数字的形式，可以回溯匹配之前分组的内容的表示，在收集html网页中不同标签内的内容很有帮助。</p>
<h2 id="环视（正向先行断言）"><a href="#环视（正向先行断言）" class="headerlink" title="环视（正向先行断言）"></a>环视（正向先行断言）</h2><p>正向先行断言：(?=表达式)，指在某个位置向右看，表示所在位置右侧必须能匹配表达式</p>
<p>例如：</p>
<p>我喜欢你 我喜欢 我喜欢我 喜欢 喜欢你</p>
<p>如果要取出喜欢两个字，要求这个喜欢后面有你，这个时候就要这么写：喜欢(?=你)，这就是正向先行断言。</p>
<p>先行断言可以用来判断字符串是否符合特定的规则，例如提取包含至少一个大小写字母的字符串</p>
<img src="/2021/04/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/24.jpg" class="" title="[]">

<h2 id="反向先行断言"><a href="#反向先行断言" class="headerlink" title="反向先行断言"></a>反向先行断言</h2><p>反向先行断言(?!表达式)的作用是保证右边不能出现某字符。</p>
<img src="/2021/04/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/25.jpg" class="" title="[]">

<h2 id="正向后行断言"><a href="#正向后行断言" class="headerlink" title="正向后行断言"></a>正向后行断言</h2><p>先行断言和后行断言只有一个区别，即先行断言从左往右看，后行断言从右往左看。</p>
<p>正向后行断言：(?&lt;=表达式)，指在某个位置向左看，表示所在位置左侧必须能匹配表达式</p>
<img src="/2021/04/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/26.jpg" class="" title="[]">

<h3 id="反向后行断言"><a href="#反向后行断言" class="headerlink" title="反向后行断言"></a>反向后行断言</h3><p>反向后行断言：(?&lt;!表达式)，指在某个位置向左看，表示所在位置左侧不能匹配表达式</p>
<p>（这个题是做崩了，看了一会儿没看明白！找了本电子书再拜读一下好了！）</p>
<hr>
<p>这篇博客就写到这里啦，关于正则其实还并没有完全掌握，后面学习时有机会会再做些补充</p>
]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python康复训练-习题</title>
    <url>/2021/04/11/python%E5%BA%B7%E5%A4%8D%E8%AE%AD%E7%BB%83-%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<p>在复习python操作的基础上，通过做一些pat的题目来巩固一下所学！题目比较基础，维持在至少一条一道的速度上，有时间会多做一些。</p>
<hr>
<h5 id="1-1001"><a href="#1-1001" class="headerlink" title="1.1001"></a>1.1001</h5><blockquote>
<p>1001 害死人不偿命的(3n+1)猜想 (15 分)<br><br>&nbsp;&nbsp;卡拉兹(Callatz)猜想:<br><br>&nbsp;&nbsp;对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数， 那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……<br><br>&nbsp;&nbsp;我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 n，简单地数一下，需要多少步（砍几下）才能得到 n=1？</p>
</blockquote>
<p>只要根据他的要求写一个循环就好</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n&#x3D;input()</span><br><span class="line">n&#x3D;int(n)</span><br><span class="line">i&#x3D;0</span><br><span class="line">while(n!&#x3D;1):</span><br><span class="line">  if(n%2&#x3D;&#x3D;0):</span><br><span class="line">    n&#x3D;n&#x2F;2</span><br><span class="line">  else:</span><br><span class="line">    n&#x3D;(3*n+1)&#x2F;2</span><br><span class="line">  i&#x3D;i+1</span><br><span class="line">print(i)</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-1002"><a href="#2-1002" class="headerlink" title="2.1002"></a>2.1002</h5><blockquote>
<p>1002 写出这个数 (20 分)<br><br>&nbsp;&nbsp;读入一个正整数 n，计算其各位数字之和，用汉语拼音写出和的每一位数字。</p>
</blockquote>
<p>题目描述很简单，这道题应用列表存储数据再进行string和int的转化即可，python中不同格式的转化十分方便！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums&#x3D;input()</span><br><span class="line">sum&#x3D;0</span><br><span class="line">for i in nums:</span><br><span class="line">    sum&#x3D;sum+int(i)</span><br><span class="line">teans&#x3D;[&#39;ling&#39;,&#39;yi&#39;,&#39;er&#39;,&#39;san&#39;,&#39;si&#39;,&#39;wu&#39;,&#39;liu&#39;,&#39;qi&#39;,&#39;ba&#39;,&#39;jiu&#39;]</span><br><span class="line">result&#x3D;[]</span><br><span class="line">for i in str(sum):</span><br><span class="line">    result.append(teans[int(i)])</span><br><span class="line">#print(result)</span><br><span class="line">for i in range(len(result)-1):</span><br><span class="line">    print(result[i],end&#x3D;&#39; &#39;)</span><br><span class="line">print(result[len(result)-1])</span><br></pre></td></tr></table></figure>
<h5 id="3-1003"><a href="#3-1003" class="headerlink" title="3.1003"></a>3.1003</h5><blockquote>
<p>1003 我要通过！ (20 分)<br><br>&nbsp;&nbsp;“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。<br><br>&nbsp;&nbsp;得到“答案正确”的条件是：<br><br>&nbsp;&nbsp;字符串中必须仅有 P、 A、 T这三种字符，不可以包含其它字符；<br><br>&nbsp;&nbsp;任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x或者是空字符串，或者是仅由字母 A 组成的字符串；<br><br>&nbsp;&nbsp;如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a、 b、 c 均或者是空字符串，或者是仅由字母 A 组成的字符串。<br><br>&nbsp;&nbsp;现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。<br></p>
</blockquote>
<p>这个题目开始尝试了字符串的处理方法，后面发现想感觉尝试正则表达会更加简便，在做题后进行了对于正则表达式的学习，对于正则表达式的总结写在了另一篇博客上。这道题也同样是一道比较考验理解能力的题目。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line">n&#x3D;input()</span><br><span class="line">n&#x3D;int(n)</span><br><span class="line">for i in range(n):</span><br><span class="line">    s&#x3D;input()</span><br><span class="line">    pa &#x3D; re.compile(r&quot;(?P&lt;a&gt;A*)P(?P&lt;b&gt;A+)T(?P&lt;c&gt;A*)&quot;)</span><br><span class="line">    if pa.match(s):</span><br><span class="line">        co &#x3D; re.split(r&quot;P|T&quot;, s)</span><br><span class="line">        if len(co[0]) * len(co[1]) &#x3D;&#x3D; len(co[2]):</span><br><span class="line">            print(&quot;YES&quot;)</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;NO&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;NO&quot;)</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h5 id="4-1004"><a href="#4-1004" class="headerlink" title="4.1004"></a>4.1004</h5><blockquote>
<p>&nbsp;&nbsp;读入 n（&gt;0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。</p>
</blockquote>
<p>这个题是一个很基础的读取输入，判断保留，输出的题，很简单，但之前没有注意输入的时候input（）会直接读取一行，和之前c熟悉的只会读取一个一个不一样，所以要使用split（‘ ’）分割！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n&#x3D;int(input())</span><br><span class="line">max&#x3D;0</span><br><span class="line">min&#x3D;100</span><br><span class="line"></span><br><span class="line">for i in range(n):</span><br><span class="line">    s&#x3D;input()</span><br><span class="line">    s&#x3D;s.split( )</span><br><span class="line">    name&#x3D;s[0]</span><br><span class="line">    num&#x3D;s[1]</span><br><span class="line">    grade&#x3D;s[2]</span><br><span class="line">    grade&#x3D;int(grade)</span><br><span class="line">    if grade&gt;max:</span><br><span class="line">        max&#x3D;grade</span><br><span class="line">        max_name&#x3D;name</span><br><span class="line">        max_num&#x3D;num</span><br><span class="line">    if grade&lt;min:</span><br><span class="line">        min&#x3D;grade</span><br><span class="line">        min_name&#x3D;name</span><br><span class="line">        min_num&#x3D;num</span><br><span class="line"></span><br><span class="line">print(max_name+&#39; &#39;+max_num)</span><br><span class="line">print(min_name+&#39; &#39;+min_num)</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="6-1006-换个格式输出整数"><a href="#6-1006-换个格式输出整数" class="headerlink" title="6.1006 换个格式输出整数"></a>6.1006 换个格式输出整数</h5><blockquote>
<p>&nbsp;&nbsp;让我们用字母 B 来表示“百”、字母 S 表示“十”，用 12…n 来表示不为零的个位数字 n（&lt;10），换个格式来输出任一个不超过 3 位的正整数。例如 234 应该被输出为 BBSSS1234，因为它有 2 个“百”、3 个“十”、以及个位的 4。</p>
</blockquote>
<p>因为输入形势变化较少，就不将字符串转化为数字了，按照字符串以分片形式读取更为方便</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">n&#x3D;input()</span><br><span class="line">if(len(n)&#x3D;&#x3D;3):</span><br><span class="line">    for i in range(int(n[-3])):</span><br><span class="line">        print(&quot;B&quot;,end&#x3D;&#39;&#39;)</span><br><span class="line">if(len(n)!&#x3D;1):</span><br><span class="line">    for i in range(int(n[-2])):</span><br><span class="line">        print(&quot;S&quot;,end&#x3D;&#39;&#39;)</span><br><span class="line">for i in range(int(n[-1])):</span><br><span class="line">    print(i+1,end&#x3D;&#39;&#39;)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<hr>
<h5 id="7-1007-素数对猜想"><a href="#7-1007-素数对猜想" class="headerlink" title="7.1007 素数对猜想"></a>7.1007 素数对猜想</h5><blockquote>
<p>&nbsp;&nbsp;让我们定义dn 为：dn =pn+1 −pn ，其中pi 是第i个素数。显然有d1 =1，且对于n&gt;1有dn 是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。<br><br>&nbsp;&nbsp;现给定任意正整数N(&lt;105)，请计算不超过N的满足猜想的素数对的个数。</p>
</blockquote>
<p>这个题不同语言实现的思路应该没什么差别，只要依靠打洞把非质数打掉，剩下的即为需要的，不过在这次实现里感觉到了python运行速度和c比确实差距很大</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n&#x3D;int(input())</span><br><span class="line">z&#x3D;[0]</span><br><span class="line">z&#x3D;z*100000</span><br><span class="line">for i in range(2,50000):</span><br><span class="line">    for j in range(i+i,100000,i):</span><br><span class="line">        z[j]&#x3D;1</span><br><span class="line">count&#x3D;0</span><br><span class="line">for i in range(2,n-1):</span><br><span class="line">    if(z[i]&#x3D;&#x3D;0 and z[i+2]&#x3D;&#x3D;0):</span><br><span class="line">        count&#x3D;count+1</span><br><span class="line">print(count)</span><br></pre></td></tr></table></figure>

<p>8.1008 数组元素循环右移问题</p>
<blockquote>
<p>一个数组A中存有N（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将A中的数据由（A0 A1 ⋯AN−1 ）变换为（AN−M ⋯AN−1 A0​ A1 ⋯AN−M−1 ）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？</p>
</blockquote>
<p>这道题其实在考研里面的算法题中遇到过，思路是两次部分转置后进行整体转置。比如123456需要让56提前，先两次部分转置变为432165，再进行整体转置就变为561234<br>不过这次代码直接就分段输出了，没有严格按照要求！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l1&#x3D;input()</span><br><span class="line">l1&#x3D;l1.split(&#39; &#39;)</span><br><span class="line">n&#x3D;int(l1[1])</span><br><span class="line">l2&#x3D;input().split(&#39; &#39;)</span><br><span class="line">n&#x3D;n%len(l2)</span><br><span class="line">n&#x3D;len(l2)-n</span><br><span class="line">for i in range(n,len(l2)):</span><br><span class="line">    if i!&#x3D;n:</span><br><span class="line">        print(&#39; &#39;,end&#x3D;&#39;&#39;)</span><br><span class="line">    print(l2[i],end&#x3D;&#39;&#39;)</span><br><span class="line"></span><br><span class="line">for i in range(0,n):</span><br><span class="line">    if n&#x3D;&#x3D;len(l2) and i&#x3D;&#x3D;0:</span><br><span class="line">        print(l2[i], end&#x3D;&#39;&#39;)</span><br><span class="line">    else:</span><br><span class="line">        print(&#39; &#39;+l2[i],end&#x3D;&#39;&#39;)</span><br></pre></td></tr></table></figure>

<h5 id="9-1009-说反话"><a href="#9-1009-说反话" class="headerlink" title="9.1009 说反话"></a>9.1009 说反话</h5><blockquote>
<p>给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。</p>
</blockquote>
<p>python的倒置可太轻松了！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l1&#x3D;input().split()</span><br><span class="line">l1&#x3D;l1[::-1]</span><br><span class="line">for i in range(len(l1)):</span><br><span class="line">    if i!&#x3D;0:</span><br><span class="line">        print(&#39; &#39;,end&#x3D;&#39;&#39;)</span><br><span class="line">    print(l1[i],end&#x3D;&#39;&#39;)</span><br></pre></td></tr></table></figure>

<h5 id="10-1010-一元多项式求导"><a href="#10-1010-一元多项式求导" class="headerlink" title="10.1010 一元多项式求导"></a>10.1010 一元多项式求导</h5><blockquote>
<p>设计函数求一元多项式的导数。（注：xn （n为整数）的一阶导数为nxn−1 。）</p>
</blockquote>
<p>也是一个按部就班的题，注意一下当仅有常数项的时候如何输出就好！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l1&#x3D;input().split()</span><br><span class="line">l1&#x3D;[int(i) for i in l1]</span><br><span class="line">if len(l1)&#x3D;&#x3D;2 and l1[-1]&#x3D;&#x3D;0:</span><br><span class="line">    print(&quot;0 0&quot;,end&#x3D;&#39;&#39;)</span><br><span class="line">else:</span><br><span class="line">    for i in range(len(l1)):</span><br><span class="line">        if((i&#x3D;&#x3D;len(l1)-1 or i&#x3D;&#x3D;len(l1)-2) and l1[-1]&#x3D;&#x3D;0):</span><br><span class="line">            continue</span><br><span class="line">        if i!&#x3D;0:</span><br><span class="line">            print(&#39; &#39;,end&#x3D;&#39;&#39;)</span><br><span class="line">        if i%2&#x3D;&#x3D;0:</span><br><span class="line">            print(l1[i]*l1[i+1],end&#x3D;&#39;&#39;)</span><br><span class="line">        if i%2&#x3D;&#x3D;1:</span><br><span class="line">            print(l1[i]-1,end&#x3D;&#39;&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="11-1011-A-B-和-C"><a href="#11-1011-A-B-和-C" class="headerlink" title="11.1011 A+B 和 C"></a>11.1011 A+B 和 C</h5><blockquote>
<p>给定区间 [−2^31 ,2^31 ] 内的 3 个整数 A、B 和 C，请判断 A+B 是否大于 C。</p>
</blockquote>
<p>就是简单的加法，连大数都不是（就算是大数python）也能轻松解决。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n &#x3D; int(input())</span><br><span class="line">for i in range(n):</span><br><span class="line">    num &#x3D; input().split()</span><br><span class="line">    num&#x3D;[int(j) for j in num]</span><br><span class="line">    if num[0]+num[1]&gt;num[2]:</span><br><span class="line">        print(&quot;Case #&quot;,i+1,&quot;: true&quot;,sep&#x3D;&quot;&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;Case #&quot;, i + 1, &quot;: false&quot;,sep&#x3D;&quot;&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="12-1012-数字分类"><a href="#12-1012-数字分类" class="headerlink" title="12.1012 数字分类"></a>12.1012 数字分类</h5><blockquote>
<p>给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字：<br><br>A1  = 能被 5 整除的数字中所有偶数的和；<br><br>A2  = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 n1 −n2 +n3 −n4 ⋯；<br><br>A3  = 被 5 除后余 2 的数字的个数；<br><br>A4  = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位；<br><br>A5  = 被 5 除后余 4 的数字中最大数字。</p>
</blockquote>
<p>一道不同情况不同处理的题，题是写起来有点麻烦但并没有思路上的问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l1&#x3D;input().split()</span><br><span class="line">l1&#x3D;l1[1:]</span><br><span class="line">l1&#x3D;[int(i) for i in l1]</span><br><span class="line">a1&#x3D;[i for i in l1 if i%5&#x3D;&#x3D;0]</span><br><span class="line">a2&#x3D;[i for i in l1 if i%5&#x3D;&#x3D;1]</span><br><span class="line">a3&#x3D;[i for i in l1 if i%5&#x3D;&#x3D;2]</span><br><span class="line">a4&#x3D;[i for i in l1 if i%5&#x3D;&#x3D;3]</span><br><span class="line">a5&#x3D;[i for i in l1 if i%5&#x3D;&#x3D;4]</span><br><span class="line">a1&#x3D;[i for i in a1 if i%2&#x3D;&#x3D;0]</span><br><span class="line">if len(a1)&#x3D;&#x3D;0:</span><br><span class="line">    print(&quot;N&quot;,end&#x3D;&#39;&#39;)</span><br><span class="line">else:</span><br><span class="line">    sum&#x3D;0</span><br><span class="line">    for i in a1:</span><br><span class="line">        if i%2&#x3D;&#x3D;0:</span><br><span class="line">            sum&#x3D;sum+i</span><br><span class="line">    print(sum,end&#x3D;&#39;&#39;)</span><br><span class="line"></span><br><span class="line">if len(a2) &#x3D;&#x3D; 0:</span><br><span class="line">    print(&quot; N&quot;, end&#x3D;&#39;&#39;)</span><br><span class="line">else:</span><br><span class="line">    sum &#x3D; 0</span><br><span class="line">    op&#x3D;1</span><br><span class="line">    for i in a2:</span><br><span class="line">        if op&#x3D;&#x3D;1:</span><br><span class="line">            sum &#x3D; sum + i</span><br><span class="line">            op&#x3D;0</span><br><span class="line">        else:</span><br><span class="line">            sum&#x3D;sum-i</span><br><span class="line">            op&#x3D;1</span><br><span class="line">    print(&quot; &quot;,end&#x3D;&quot;&quot;)</span><br><span class="line">    print(sum, end&#x3D;&#39;&#39;)</span><br><span class="line"></span><br><span class="line">if len(a3) &#x3D;&#x3D; 0:</span><br><span class="line">    print(&quot; N&quot;, end&#x3D;&#39;&#39;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot; &quot;, end&#x3D;&quot;&quot;)</span><br><span class="line">    print(len(a3), end&#x3D;&#39;&#39;)</span><br><span class="line"></span><br><span class="line">if len(a4) &#x3D;&#x3D; 0:</span><br><span class="line">    print(&quot; N&quot;, end&#x3D;&#39;&#39;)</span><br><span class="line">else:</span><br><span class="line">    sum&#x3D;0</span><br><span class="line">    for i in a4:</span><br><span class="line">        sum+&#x3D;i</span><br><span class="line">    avg&#x3D;sum&#x2F;len(a4)</span><br><span class="line">    print(&quot; &quot;, end&#x3D;&quot;&quot;)</span><br><span class="line">    print(&quot;%.1f&quot;%avg, end&#x3D;&#39;&#39;)</span><br><span class="line"></span><br><span class="line">if len(a5) &#x3D;&#x3D; 0:</span><br><span class="line">    print(&quot; N&quot;, end&#x3D;&#39;&#39;)</span><br><span class="line">else:</span><br><span class="line">    max&#x3D;0</span><br><span class="line">    for i in a5:</span><br><span class="line">        if i&gt;max:</span><br><span class="line">            max&#x3D;i</span><br><span class="line">    print(&quot; &quot;, end&#x3D;&quot;&quot;)</span><br><span class="line">    print(max, end&#x3D;&#39;&#39;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python康复训练-操作</title>
    <url>/2021/04/05/python%E5%BA%B7%E5%A4%8D%E8%AE%AD%E7%BB%83-1/</url>
    <content><![CDATA[<p>因为这次都是简单操作，也是康复训练，就不写什么解释啦，贴上实验的代码表示自己确实在努力试图康复好啦！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;hello world&quot;)</span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">2+3</span><br><span class="line">5</span><br><span class="line">2*3</span><br><span class="line">6</span><br><span class="line">2**3</span><br><span class="line">8</span><br><span class="line">4**2</span><br><span class="line">16</span><br><span class="line">（2+3）**4</span><br><span class="line">  File &quot;&lt;input&gt;&quot;, line 1</span><br><span class="line">    （2+3）**4</span><br><span class="line">     ^</span><br><span class="line">SyntaxError: invalid character in identifier</span><br><span class="line">(2+3)**4</span><br><span class="line">625</span><br><span class="line">a&#x3D;2</span><br><span class="line">b&#x3D;3</span><br><span class="line">a**b</span><br><span class="line">8</span><br><span class="line">3*0.1</span><br><span class="line">0.30000000000000004</span><br><span class="line">&quot;hello &quot;+str(a**b)+&quot;!&quot;</span><br><span class="line">&#39;hello 8!&#39;</span><br><span class="line">3&#x2F;2</span><br><span class="line">1.5</span><br><span class="line">int(2&#x2F;3)</span><br><span class="line">0</span><br><span class="line">import this</span><br><span class="line">The Zen of Python, by Tim Peters</span><br><span class="line">Beautiful is better than ugly.</span><br><span class="line">Explicit is better than implicit.</span><br><span class="line">Simple is better than complex.</span><br><span class="line">Complex is better than complicated.</span><br><span class="line">Flat is better than nested.</span><br><span class="line">Sparse is better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren&#39;t special enough to break the rules.</span><br><span class="line">Although practicality beats purity.</span><br><span class="line">Errors should never pass silently.</span><br><span class="line">Unless explicitly silenced.</span><br><span class="line">In the face of ambiguity, refuse the temptation to guess.</span><br><span class="line">There should be one-- and preferably only one --obvious way to do it.</span><br><span class="line">Although that way may not be obvious at first unless you&#39;re Dutch.</span><br><span class="line">Now is better than never.</span><br><span class="line">Although never is often better than *right* now.</span><br><span class="line">If the implementation is hard to explain, it&#39;s a bad idea.</span><br><span class="line">If the implementation is easy to explain, it may be a good idea.</span><br><span class="line">Namespaces are one honking great idea -- let&#39;s do more of those!</span><br><span class="line">bicycle&#x3D;[&#39;123&#39;,&#39;234&#39;]</span><br><span class="line">bicycle</span><br><span class="line">[&#39;123&#39;, &#39;234&#39;]</span><br><span class="line">bicycle[0]</span><br><span class="line">&#39;123&#39;</span><br><span class="line">bicycle[0].title()</span><br><span class="line">&#39;123&#39;</span><br><span class="line">bicycle[-2]</span><br><span class="line">&#39;123&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 博客建立</title>
    <url>/2021/03/28/blog1/</url>
    <content><![CDATA[<p>之前一直想建个博客试一试，现在有点时间啦，也有孙嘉硕同学的指导和推荐，建一个小博客再慢慢完善吧！</p>
<p>建立博客大概有安装软件，配置仓库，进行上传，选择主题，设置信息这几个步骤，依次列一列好啦</p>
<hr>
<h3 id="一、安装软件"><a href="#一、安装软件" class="headerlink" title="一、安装软件"></a>一、安装软件</h3><p>1.下载<a href="https://nodejs.org/en/">node.js</a>和<a href="https://git-scm.com/downloads/">Git</a>两个软件。</p>
<p>Node.js 是运行在服务端的JavaScript，用以在前端创建自己的服务。</p>
<p>git则主要用于维持项目与github的更新管理。</p>
<p>2.安装完node.js后，获得项目管理工具npm，这时候我们使用淘宝的镜像整一个中国的npm镜像的客户端cnpm</p>
<p>下面的命令是在cmd中输入的，并且是在你希望将博客部署在的盘符下输入</p>
<blockquote>
<p>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p>
</blockquote>
<p>在相应盘符下输入如下，来验证安装是否成功</p>
<blockquote>
<p>node -v<br><br>npm -v<br><br>cnpm</p>
</blockquote>
<p>3.如果安装成功的话，可以进行Hexo的安装</p>
<blockquote>
<p>cnpm install -g hexo-cli</p>
</blockquote>
<p>检验Hexo是否安装成功：</p>
<blockquote>
<p>hexo -v</p>
</blockquote>
<p>4.现在东西就都有啦，新建一个目录作为你的博客在本地的部署吧！</p>
<p>在cmd中输入这些可以新建目录（图形化操作就好！）</p>
<blockquote>
<p>d:<br><br>mkdir myblog<br><br>cd myblog</p>
</blockquote>
<p>好的你已经在你的文件夹里了，这时候再初始化hexo就好啦</p>
<blockquote>
<p>hexo init</p>
</blockquote>
<p>运行测试一下：</p>
<blockquote>
<p>hexo clean #用来清理缓存文件 <br><br>hexo g      #生成文件<br><br>hexo  s     #运行本地服务器<br><br>hexo  d   #上传到服务器（这个现在用不到嗷）</p>
</blockquote>
<p>运行时，先使用命令：</p>
<blockquote>
<p>hexo s</p>
</blockquote>
<p>打开浏览器的localhost:4000，查看本地登录是否成功，若成功，就可以进入部署仓库的步骤啦！</p>
<hr>
<h3 id="二、配置仓库"><a href="#二、配置仓库" class="headerlink" title="二、配置仓库"></a>二、配置仓库</h3><p>大家一定都有github账号吧，注意一个小问题是github账号的邮箱一定要公开，要不一会儿会出现一点小问题。</p>
<p>先在github上新建一个仓库，仓库的名字为 <strong>[github用户名].github.io</strong> 特别要注意，第一个字段一定要和你的github用户名一致，要不github不会识别这个仓库为gitpage！</p>
<p>建好这个仓库，我们会有这个仓库的网址，格式应该是 <a href="https://github.com/Tinkerver/tinkerver.github.io">https://github.com/Tinkerver/tinkerver.github.io</a><br>这个样子，我们可以复制一下它！</p>
<p>打开我们刚刚初始化hexo所在的文件夹，找到_config.yml文件。点开它向下拖拖到最后会看到deploy:字段，我们把它补全就好啦，格式像这个样子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">   type: git</span><br><span class="line">   repo: https:&#x2F;&#x2F;github.com&#x2F;MrSunCodes&#x2F;tinkever.github.io.git</span><br><span class="line">   branch: master</span><br></pre></td></tr></table></figure>

<p>做完这些，就只剩最后一步啦<br>在我们的项目文件夹下</p>
<blockquote>
<p>hexo d</p>
</blockquote>
<p>就可以把本地部署好的博客上传到github仓库，也就可以访问啦！</p>
<blockquote>
<p><a href="https://tinkerver.github.io/">https://tinkerver.github.io/</a></p>
</blockquote>
<p>这个格式的地址就是你的个人主页！</p>
<hr>
<h3 id="三、选择主题"><a href="#三、选择主题" class="headerlink" title="三、选择主题"></a>三、选择主题</h3><p>首先选择一个自己喜欢的<a href="https://link.zhihu.com/?target=https://hexo.io/themes/">主题</a>！<br>在选出自己喜欢的主题之后，在项目目录中输入</p>
<blockquote>
<p>git clone <a href="https://github.com/iissnan/hexo-theme-next">https://github.com/iissnan/hexo-theme-next</a> themes/[你喜欢的主题名]</p>
</blockquote>
<p>这样你的themes文件夹中就得到相应的主题，再对主目录下_config.yml的theme字段，比如如果使用next主题，就应该</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<p>特别要注意，theme：后面需要保留空格，不然后面会报错</p>
<p>更改主题后，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean  #清理缓存文件 </span><br><span class="line">hexo g      #生成文件</span><br><span class="line">hexo  s     #运行本地服务器</span><br></pre></td></tr></table></figure>
<p>来在本地服务上看一看主题是不是喜欢，喜欢的话</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo  d   #上传到服务器</span><br></pre></td></tr></table></figure>

<p>我在完成这一部分的时候，遇到更换主题后打开网页出现乱码的情况，这种情况下似乎是原因是因为hexo在5.0之后把swig给删除了需要自己手动安装，所以要输入</p>
<blockquote>
<p>npm i hexo-renderer-swig</p>
</blockquote>
<p>这行代码安装就好。</p>
<p>这样我们就完成了主题的更换！</p>
<hr>
<h3 id="四、信息设置"><a href="#四、信息设置" class="headerlink" title="四、信息设置"></a>四、信息设置</h3><p>修改博客的样式，需要修改主目录下的 _config.yml文件，以及themes/你的主题下的 _config.yml文件</p>
<p>这个东西好玄妙的，我也没有弄清楚，嘉硕给了两个例子，依照这两个例子来好啦！</p>
<p><a href="https://github.com/litten/hexo-theme-yilia/blob/master/_config.yml">theme下的_config.yml文件</a></p>
<p><a href="https://github.com/litten/BlogBackup/blob/master/_config.yml">主目录的 _config.yml文件</a></p>
<p>好啦，第一篇博客到此为止！</p>
<p>测试一下更改会怎么样！</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/03/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
